#' Global ACF test
#'
#' Tests whether the residuals from a time series model has acceptable autocorrelation in the residuals.
#'
#' Version 4.4, 5/15/2024
#'
#' @param seas_obj Object generated by \code{seas()} of the \code{seasonal} package.
#'        This is a required entry.
#' @param num_sig Limit for number of lags with significant ACF values
#'        Default is \code{8}.
#' @param acf_lags_fail - lags of the ACF to test
#'        Default is \code{c(1, 2, 3, 4, 12, 24)}.
#' @param acf_lags_warn - lags of the ACF to test for warnings
#'        Default is \code{c(12, 24)}.
#' @param include_pacf Logical scalar that indicates if the PACF is included in the testing.
#'        Default is TRUE
#' @param return_this character string; what the function returns - 
#'        \code{'test'} returns test results, \code{'why'} returns why the test failed or 
#'        received a warning, or \code{'both'}. Default is \code{'test'}.
#' @return A text string denoting if series passes, fails, or has a warning for residual 
#'         autocorrelation. If model diagnostics not found, return \code{'none'}.
#'
#' @author Brian C. Monsell, \email{monsell.brian@@bls.gov} or \email{bcmonsell@@gmail.com}
#'
#' @examples
#' ukgas_seas <- seasonal::seas(UKgas, series.period = 4, arima.model = "(0 1 1)(0 1 1)", 
#'                              x11="", transform.function = "log", forecast.maxlead=20,
#'                              check.print = c( "pacf", "pacfplot" ))
#' ukgas_acf_test <- acf_test(ukgas_seas, num_sig = 4, acf_lags_fail = c(1, 2, 3, 4, 8),
#'                            acf_lags_warn = c(4, 8), return_this = "both")
#' @export
acf_test <- function(seas_obj = NULL, num_sig = 8, acf_lags_fail = c(1, 2, 3, 4, 12, 24), 
                     acf_lags_warn = c(12, 24), include_pacf = TRUE, return_this = "test") {
    # Author: Brian C. Monsell (OEUS) Version 4.4, 5/15/2024
    
    # check if a value is specified for \code{seas_obj}
    if (is.null(seas_obj)) {
        stop("must specify a seas object")
    } else {
    # check if a seas object is specified for \code{seas_obj}
        if (!inherits(seas_obj, "seas")) {
            stop("First argument must be a seas object")
        }
    }
    
    # set \code{is_test}, \code{is_why}, \code{is_both}
    is_test <- FALSE
    is_why <- FALSE
    is_both <- FALSE
    return_this <- tolower(return_this)
    if (return_this == "test") {
        is_test <- TRUE
    }
    if (return_this == "why") {
        is_why <- TRUE
    }
    if (return_this == "both") {
        is_test <- TRUE
        is_why <- TRUE
        is_both <- TRUE
    }
    
    # check for improper entry for \code{return_this}
    if (!is_test & !is_why) {
        print(paste("Improper entry for return_this : ", return_this, sep = ""))
        return(NULL)
    }
    
    # check to see if a regARIMA model was estimated in this run.  
    # If not, return \code{'none'}
    udg_all <- seasonal::udg(seas_obj)
    if (udg_all[["mdg"]] == "no") {
        if (is_both) {
            return(c("none","    "))
        } else {
            return("none")
        }
    }
    # determine if series fails ACF test with function \code{acf_fail} 
    # if so, set this_test to \code{'fail'}
    this_fail <- acf_fail(udg_all, acf_lags_fail, num_sig, include_pacf)
    if (this_fail) {
        this_test <- "fail"
        this_why <- acf_fail_why(udg_all, acf_lags_fail, num_sig, 
                                 include_pacf, return_both = is_both)
    } else {
        # else, do further ACF testing with function \code{acf_warn} if so, set \code{this_test} to
        # \code{'warn'} else set \code{this_test} to \code{'pass'}.
        this_warn <- acf_warn(udg_all, acf_lags_warn)
        if (this_warn) {
            this_test <- "warn"
            this_why <- acf_warn_why(udg_all, acf_lags_warn, return_both = is_both)
        } else {
            this_test <- "pass"
            this_why <- "    "
            if (return_this == "why") {
                this_why <- "pass"
            }
        }
    }
    
    # return results based on entry of \code{return_this}
    if (is_both) {
        return(cbind(this_test, this_why))
    }
    if (is_test) {
        return(this_test)
    }
    return(this_why)
}
