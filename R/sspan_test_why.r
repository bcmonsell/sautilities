#' Sliding Spans Diagnostic Warning Messages
#'
#' Generate text on why tests using the sliding spans diagnostic fail.
#'
#' Version 4.2, 5/24/2023
#'
#' @param udg_list List object generated by \code{udg()} function of the \code{seasonal} package.
#'        This is a required entry.
#' @param sf_limit Numeric object; limit for the percentage of seasonal spans flagged.
#'        Default is 25.
#' @param additivesa logical scalar; if true, the adjustment is assumed to be additive; 
#'        default is \code{FALSE}.
#' @param change_limit Numeric object; limit for the percentage of month-to-month changes flagged.
#'        Default is 40.
#' @param return_both Logical scalar indicating whether the calling function will return both 
#'        the test results and why the test failed or produced a warning. Default is \code{TRUE}.
#' @return A text string denoting if the series passed the tests of sliding spans diagnostics 
#'         diagnostics, or why the series failed.
#'
#' @author Brian C. Monsell, \email{monsell.brian@@bls.gov} or \email{bcmonsell@@gmail.com}
#'
#' @examples
#' ukgas_seas <- seasonal::seas(UKgas, series.period = 4, arima.model = "(0 1 1)(0 1 1)", 
#'                              x11="", transform.function = "log", forecast.maxlead=20,
#'                              check.print = c( "pacf", "pacfplot" ))
#' ukgas_seas_udg <- seasonal::udg(ukgas_seas)
#' ukgas_sspan_test_why <- 
#'    sspan_test_why(ukgas_seas_udg, sf_limit = 15, change_limit = 35, return_both = TRUE)
#' @export
sspan_test_why <- function(udg_list = NULL, sf_limit = 25, change_limit = 40, additivesa = FALSE, 
                           return_both = FALSE) {
    # Author: Brian C. Monsell (OEUS) Version 4.2, 5/24/2023
    
    # check if a value is specified for \code{udg_list}
    if (is.null(udg_list)) {
        stop("must specify a list of UDG diagnostics")
    } else {
        if (!is.list(udg_list)) {
            stop("must specify a list")
        }
    }
    
    # check if sliding spans are generated
    if (udg_list[["sspans"]] == "no") {
        return("none")
    }
    if (udg_list[["sspans"]] == "failed") {
        return("failed")
    }
    
    # check to see if differences were tested rather than percentages.  
    # If so, return \code{'diff'}.
    if (udg_list[["ssdiff"]] == "yes") {
        return("diff")
    }
    
    # check to see if range is too small to generate precentages.  
    # If so, return \code{'no.pct'}.
    if (udg_list[["s2.pct"]] == "no") {
        return("no.pct")
    }
    
    # check to see if the percentage of seasonal factors flagged is > \code{sf_limit}.  
    # If so, return \code{'warn'}
    this_freq <- udg_list[["freq"]]
    this_out_string <- ""
    if (additivesa) {
        # check to see if the percentage of sa flagged is > \code{sf_limit}.  
        # if so, return \code{'warn'}.
        is_this_add <- length(udg_list[["s2.c.per"]])
        if (is_this_add > 0) {
            this_key <- "s2.c.per"
        } else {
            this_key <- "s2.a.per"
        }
        if (udg_list[[this_key]][3] > sf_limit) {
            this_out_string <- paste("S(%) >", sf_limit)
            if (!return_both) {
                this_out_string <- paste("warn: ", this_out_string, sep = "")
            }
        }
    } else {
        if (udg_list[["s2.a.per"]][3] > sf_limit) {
            this_out_string <- paste("S(%) >", sf_limit)
            if (!return_both) {
                this_out_string <- paste("warn: ", this_out_string, sep = "")
            }
        }
    }
    
    # check to see if the percentage of changes flagged is > \code{change_limit}.  
    # If so, return \code{'warn'}.
    if (udg_list[["s2.d.per"]][3] > change_limit) {
        if (nchar(this_out_string) > 0) {
            this_out_string <- paste(this_out_string, ";", sep = "")
        } else {
            if (!return_both) {
                this_out_string <- "warn: "
            }
        }
        if (this_freq == 12) {
            this_out_string <- paste(this_out_string, "MM(%) >", change_limit)
        } else {
            this_out_string <- paste(this_out_string, "QQ(%) >", change_limit)
        }
    }
    
    # else, return pass
    if (nchar(this_out_string) > 0) {
        return(this_out_string)
    } else {
        # else return 'pass' or blanks
        if (return_both) {
            return("    ")
        } else {
            return("pass")
        }
    }
    
}
