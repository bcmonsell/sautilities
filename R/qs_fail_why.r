#' QS diagnostic failure message
#'
#' generates text explaining why the QS diagnostic failed or generated a warning.
#'
#' Version 4.2, 5/23/2023
#'
#' @param udg_list List object generated by \code{udg()} function of the \code{seasonal} package.
#'        This is a required entry.
#' @param test_full Logical scalar indicating whether to test the full series span.
#'        Default is \code{TRUE}.
#' @param test_span Logical scalar indicating whether to test the final 8-year span used 
#'        by the spectrum diagnostic. Default is \code{TRUE}.
#' @param p_limit_fail Numeric scalar; P-value limit for QS statistic for failure.
#'        Default is \code{0.01}.
#' @param robust_sa Logical scalar indicating if SA or irregular series adjusted for extremes 
#'        is included in testing. Default is \code{TRUE}.
#' @param return_both Logical scalar indicating whether the calling function will return both 
#'        the test results and why the test failed or produced a warning. 
#'        Default is \code{FALSE}.
#' @return  A text string denoting why the series failed the tests of QS diagnostics.
#'
#' @author Brian C. Monsell, \email{monsell.brian@@bls.gov} or \email{bcmonsell@@gmail.com}
#'
#' @examples
#' ukgas_seas <- seasonal::seas(UKgas, series.period = 4, arima.model = "(0 1 1)(0 1 1)", 
#'                              x11="", transform.function = "log", forecast.maxlead=20,
#'                              check.print = c( "pacf", "pacfplot" ))
#' ukgas_udg <- seasonal::udg(ukgas_seas)
#' ukgas_qs_test <- 
#'     qs_fail_why(ukgas_udg, test_full = FALSE, p_limit_fail = 0.01, return_both = TRUE)
#' @export
qs_fail_why <- function(udg_list = NULL, test_full = TRUE, test_span = TRUE,  
                        p_limit_fail = 0.01, robust_sa = TRUE, return_both = FALSE) {
    # Author: Brian C. Monsell (OEUS) Version 4.2, 5/23/2023
    
    # check if a value is specified for \code{udg_list}
    if (is.null(udg_list)) {
        stop("must specify a list of UDG diagnostics")
    } else {
        if (!is.list(udg_list)) {
            stop("must specify a list")
        }
    }
    
    # Initialize \code{this_out_string}
    this_out_string <- ""
    
    # Test full span of series
    if (test_full) {
        # initialize number of tests failed to 0
        n_test <- 0
        
        # get index of the QS statistic for the seasonally adjusted data
        index_qs <- get_udg_index(udg_list, "qssadj")
        
        # If this QS exists, check if the test fails, update \code{this_out_string} and 
        # \code{n_test} if necessary
        if (index_qs > 0) {
            if (udg_list[["qssadj"]][2] < p_limit_fail) {
                this_out_string <- "sadj"
                if (!return_both) {
                  this_out_string <- paste("fail:", this_out_string, sep = " ")
                }
            }
            n_test <- n_test + 1
        }
        
        # get index of the QS statistic for the irregular component
        index_qs <- get_udg_index(udg_list, "qsirr")
        
        # If this QS exists, check if the test fails, update \code{this_out_string} and 
        # \code{n_test} if necessary
        if (index_qs > 0) {
            is_irr_fail <- udg_list[["qsirr"]][2] < p_limit_fail
            if (is_irr_fail) {
                if (nchar(this_out_string) > 0) {
                  this_out_string <- paste(this_out_string, ";irr", sep = "")
                } else {
                  this_out_string <- "irr"
                  if (!return_both) {
                    this_out_string <- paste("fail:", this_out_string, sep = " ")
                  }
                }
            }
            n_test <- n_test + 1
        }
        
        # Test series adjusted for extremes
        if (robust_sa) {
            # get index of the QS statistic for the seasonally adjusted data adjusted for extreme values
            index_qs <- get_udg_index(udg_list, "qssadjevadj")
            
            # If this QS exists, check if the test fails, update \code{this_out_string} and \{n_test} if
            # necessary
            if (index_qs > 0) {
                if (udg_list[["qssadjevadj"]][2] < p_limit_fail) {
                  if (nchar(this_out_string) > 0) {
                    this_out_string <- paste(this_out_string, ";sadjevadj", sep = "")
                  } else {
                    this_out_string <- "sadjevadj"
                    if (!return_both) {
                      this_out_string <- paste("fail:", this_out_string, sep = " ")
                    }
                  }
                }
                n_test <- n_test + 1
            }
            
            # get index of the QS statistic for the irregular adjusted for extreme values
            index_qs <- get_udg_index(udg_list, "qsirrevadj")
            
            # If this QS exists, check if the test fails, update \code{this_out_string} and 
            # \code{n_test} if necessary
            if (index_qs > 0) {
                if (udg_list[["qsirrevadj"]][2] < p_limit_fail) {
                  if (nchar(this_out_string) > 0) {
                    this_out_string <- paste(this_out_string, ";irrevadj", sep = "")
                  } else {
                    this_out_string <- "irrevadj"
                    if (!return_both) {
                      this_out_string <- paste("fail:", this_out_string, sep = " ")
                    }
                  }
                }
                n_test <- n_test + 1
            }
        }
        
        # If no QS statistics are found, return \code{'no_qs_stats'}
        if (n_test == 0) {
            return("no_qs_stats")
        }
    }
    
    # Test reduced (8-year) span of series
    if (test_span) {
        # initialize number of tests failed to 0
        n_test <- 0
        
        # get index of the QS statistic for the seasonally adjusted
        index_qs <- get_udg_index(udg_list, "qsssadj")
        
        # If this QS exists, check if the test fails, update \code{this_out_string} and 
        # \code{n_test} if necessary
        if (index_qs > 0) {
            if (udg_list[["qsssadj"]][2] < p_limit_fail) {
                if (nchar(this_out_string) > 0) {
                  this_out_string <- paste(this_out_string, ";sadj.span", sep = "")
                } else {
                  this_out_string <- "sadj.span"
                  if (!return_both) {
                    this_out_string <- paste("fail:", this_out_string, sep = " ")
                  }
                }
            }
            n_test <- n_test + 1
        }
        
        # get index of the QS statistic for the irregular
        index_qs <- get_udg_index(udg_list, "qssirr")
        
        # If this QS exists, check if the test fails, update \code{this_out_string} and 
        # \code{n_test} if necessary
        if (index_qs > 0) {
            if (udg_list[["qssirr"]][2] < p_limit_fail) {
                if (nchar(this_out_string) > 0) {
                  this_out_string <- paste(this_out_string, ";irr.span", sep = "")
                } else {
                  this_out_string <- "irr.span"
                  if (!return_both) {
                    this_out_string <- paste("fail:", this_out_string, sep = " ")
                  }
                }
            }
            n_test <- n_test + 1
        }
        
        # Test series adjusted for extremes
        if (robust_sa) {
            # get index of the QS statistic for the seasonally adjusted data adjusted 
            # for extreme values
            index_qs <- get_udg_index(udg_list, "qsssadjevadj")
            
            # If this QS exists, check if the test fails, update \code{this_out_string} 
            # and \code{n_test} if necessary
            if (index_qs > 0) {
                if (udg_list[["qsssadjevadj"]][2] < p_limit_fail) {
                  if (nchar(this_out_string) > 0) {
                    this_out_string <- paste(this_out_string, ";sadjevadj.span", sep = "")
                  } else {
                    this_out_string <- "sadjevadj.span"
                    if (!return_both) {
                      this_out_string <- paste("fail:", this_out_string, sep = " ")
                    }
                  }
                }
                n_test <- n_test + 1
            }
            
            # get index of the QS statistic for the irregular adjusted for extreme values
            index_qs <- get_udg_index(udg_list, "qssirrevadj")
            
            # If this QS exists, check if the test fails, update \code{this_out_string} and 
            # \code{n_test} if necessary
            if (index_qs > 0) {
                if (udg_list[["qssirrevadj"]][2] < p_limit_fail) {
                  if (nchar(this_out_string) > 0) {
                    this_out_string <- paste(this_out_string, ";irrevadj.span", sep = "")
                  } else {
                    this_out_string <- "irrevadj.span"
                    if (!return_both) {
                      this_out_string <- paste("fail:", this_out_string, sep = " ")
                    }
                  }
                }
                n_test <- n_test + 1
            }
        }
        
        # If no QS statistics are found, return \code{'no_span_qs_stats'}
        if (n_test == 0) {
            return("no_span_qs_stats")
        }
    }
    
    # return results based on entry of \code{return_this}
    if (nchar(this_out_string) > 0) {
        return(this_out_string)
    } else {
        if (return_both) {
            return("    ")
        } else {
            return("pass")
        }
    }
    
}
