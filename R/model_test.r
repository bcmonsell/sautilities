#' Tests Time Series Model.
#'
#' Tests whether the time series model has acceptable diagnostics.
#'
#' Version 4.4, 5/14/2024
#'
#' @param seas_obj Object generated by \code{seas()} of the \code{seasonal} package.
#'        This is a required entry.
#' @param t_value t-statistic limit for regressors. Default is \code{3}.
#' @param p_value p-value limit for regressors. Default is \code{0.01}.
#' @param otl_auto_limit Numeric object; limit for number of automatically identified outliers.
#'        Default is \code{4}.
#' @param otl_all_limit Numeric object; limit for number of outlier regressors.
#'        Default is \code{6}.
#' @param return_this character string; what the function returns - \code{'test'} 
#         returns test results, \code{'why'} returns why the test failed or received a warning, 
#'        or \code{'both'}. Default is \code{'both'}.
#' @return A text string denoting if the series passed or failed the tests of ARIMA diagnostics.
#'
#' @author Brian C. Monsell, \email{monsell.brian@@bls.gov} or \email{bcmonsell@@gmail.com}
#'
#' @examples
#' ukgas_seas <- 
#'    seasonal::seas(UKgas, series.period = 4, arima.model = "(0 1 1)(0 1 1)", 
#'                   x11="", transform.function = "log", forecast.maxlead=20,
#'                   check.print = c( "pacf", "pacfplot" ))
#' ukgas_model <- model_test(ukgas_seas, t_value=3.0, p_value=0.01, otl_auto_limit=4, 
#'                           otl_all_limit=6)
#' @import stats
#' @export
model_test <- function(seas_obj = NULL, t_value = 3, p_value = 0.05, otl_auto_limit = 5, 
                       otl_all_limit = 5, return_this = "test") {
    # Author: Brian C. Monsell (OEUS) Version 4.4, 5/14/2024
    
    # check if a value is specified for \code{seas_obj}
    if (is.null(seas_obj)) {
        stop("must specify a seas object")
    } else {
    # check if a seas object is specified for \code{seas_obj}
        if (!inherits(seas_obj, "seas")) {
           stop("First argument must be a seas object")
        }
    }
    
    # set \code{is_test}, \code{is_why}, \code{is_both}
    is_test <- FALSE
    is_why <- FALSE
    is_both <- FALSE
    if (return_this == "test") {
        is_test <- TRUE
    }
    if (return_this == "why") {
        is_why <- TRUE
    }
    if (return_this == "both") {
        is_test <- TRUE
        is_why <- TRUE
        is_both <- TRUE
    }
    
    # check for improper entry for \code{return_this}
    if (!is_test & !is_why) {
        print(paste("Improper entry for return_this : ", return_this, sep = ""))
        return(NULL)
    }
    
    # check to see if a regARIMA model was estimated in this run.  If not, return \code{'none'} 
    # Add test for whether automatic outlier identification is done.
    this_udg <- seasonal::udg(seas_obj)
    
    if (this_udg[["mdg"]] == "no") {
        if (is_both) {
            return(c("none","    "))
        } else {
            return("none")
        }
    }
    
    # check to see if the estimation of the regARIMA model converged in this run.  
    # if not, return \code{'no_convergance'}
    if (this_udg[["converged"]] == "no") {
        if (is_both) {
            return(c("no_convergance","    "))
        } else {
            return("no_convergance")
        }
    }
    this_warn <- FALSE
    
    # check to see if either the total number of outliers or the number of automatically identified
    # outliers are greater than their assigned limits in this run.  
    # if so, set this_warn to \code{TRUE}
    if (this_udg[["outlier.total"]] > otl_all_limit) {
        this_warn <- TRUE
    }
    if (sum(names(this_udg) == "autoout") > 0) {
        if (this_udg[["autoout"]] > otl_auto_limit) {
            this_warn <- TRUE
        }
    }
    
    # check to see if the regARIMA residuals pass Geary's a test for normality.  
    # if not, set \code{this_warn} to \code{TRUE}
    this_index <- get_udg_index(this_udg, "a")
    if (this_index > 0) {
        this_geary_a <- this_udg[[this_index]]
        if (length(this_geary_a) == 2) {
            this_warn <- TRUE
        }
    }
    
    # check to see if at least one of the regression t-statistics is greater than t_value, 
    # or the p-value is greater than p_value.  if so, set \code{this_warn} to \code{TRUE}
    number_of_regs <- this_udg[["nreg"]]
    number_of_eff_obs <- this_udg[["nefobs"]]
    p_limit <- qt(1 - (p_value/2), df = number_of_eff_obs)
    if (number_of_regs > 0) {
        num_sig_t_value <- 0
        num_sig_p_value <- 0
        reg_index <- get_udg_index(this_udg, "nreg")
        for (i in 1:number_of_regs) {
            this_index <- reg_index + i
            this_t_stat <- this_udg[[this_index]][3]
            if (abs(this_t_stat) > t_value) 
                num_sig_t_value = num_sig_t_value + 1
            if (abs(this_t_stat) > p_limit) 
                num_sig_p_value = num_sig_p_value + 1
        }
        reg_derived_index <- get_udg_index(this_udg, "nregderived")
        if (reg_derived_index == 0) {
            if (num_sig_p_value == 0) {
                this_warn <- TRUE
            }
            if (num_sig_t_value == 0) {
                this_warn <- TRUE
            }
        } else {
            number_of_derived_regs <- this_udg[[reg_derived_index]]
            for (i in 1:number_of_derived_regs) {
                this_index <- reg_derived_index + i
                this_t_stat <- this_udg[[this_index]][3]
                if (abs(this_t_stat) > t_value) 
                  num_sig_t_value = num_sig_t_value + 1
                if (abs(this_t_stat) > p_limit) 
                  num_sig_p_value = num_sig_p_value + 1
            }
            if (num_sig_p_value == 0) {
                this_warn <- TRUE
            }
            if (num_sig_t_value == 0) {
                this_warn <- TRUE
            }
        }
    }
    
    # If a warning is generated, generate text to show why
    if (this_warn) {
        this_why <- 
            model_test_why(this_udg, t_value, p_value, otl_auto_limit, otl_all_limit, 
                           return_both = is_both)
        this_test <- "warn"
    } else {
        this_test <- "pass"
        this_why <- "    "
        if (return_this == "why") {
            this_why <- "pass"
        }
    }
    
    # return test results or why text according to \code{return_this} argument
    if (return_this == "both") {
        return(cbind(this_test, this_why))
    }
    if (is_test) {
        return(this_test)
    }
    return(this_why)
    
}
